/* 
 * Search for pseudo collision in md5 hash funcion using a birthday attack approach
 */

#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<time.h>
#include<omp.h>

#include"md5.h"
#include"generator.h"

#define MAX 50000               /* How many hashes will be generated */
#define DESIRED_COLLISION 17    /* How many bytes must be equal to be considered a collision */
#define BUFFER_SIZE 22          /* The size for create a string representation of a number */

#define WARNING_AFTER 10000     /* Period of repetition to warn status */
#define THREADS 4
#define CURRENT_TRD omp_get_thread_num()

int main(int argc, char *argv[])
{
    unsigned long long int values[MAX];
    char *hashes[MAX];
    char buffers[THREADS][BUFFER_SIZE];
    unsigned char byte_collisions[THREADS];  /* Counts equal bytes in two hashes */
    unsigned int i[THREADS], j[THREADS], k[THREADS];

    seed_generator();
    printf("==> Generating %lu random messages...\n", MAX);

    clock_t start = clock();

    # pragma omp parallel num_threads(THREADS)
    for (i[CURRENT_TRD] = 0; i[CURRENT_TRD] < MAX; i[CURRENT_TRD]++){
        /* Display how many hashes were already processed */
        if(i[CURRENT_TRD] % WARNING_AFTER == 0){
            printf("==> Status: %d hashes processed\n", i[CURRENT_TRD]); 
        }

        values[i[CURRENT_TRD]] = generate_number(); 
        values[i[CURRENT_TRD]] = (values[i[CURRENT_TRD]] << 32) | generate_number();

        snprintf(buffers[CURRENT_TRD], BUFFER_SIZE, "%ld", values[i[CURRENT_TRD]]); /* Representing the number as string for hash process */
        hashes[i[CURRENT_TRD]] = md5(buffers[CURRENT_TRD], strlen(buffers[CURRENT_TRD]));         /* Get the hexadecimal md5 hash */

        for (j[CURRENT_TRD] = 0; j[CURRENT_TRD] < i[CURRENT_TRD]; j[CURRENT_TRD]++){
            byte_collisions[CURRENT_TRD] = 0;

            /* 
             * It's possible to have same numbers being generated by random function.
             * Of course, they are equal, not collision.
             */
            if (values[i[CURRENT_TRD]] == values[j[CURRENT_TRD]]){
                continue; 
            }

            /* Check how many bytes are equal */
            for (k[CURRENT_TRD] = 0; k[CURRENT_TRD] < MD5_HEX_DIGEST_SIZE; k[CURRENT_TRD]++){
                /*
                 * Checks whether it's possible to satisfy the desired collision value with the remaining bytes to test.
                 * Remaining tries + collisions found must be equal or greater than desired collision value.
                 * This prevents to continue test hashes that doesn't satisfy the desired collision value, improving performance.
                 */
                if(((MD5_HEX_DIGEST_SIZE - 1) - k[CURRENT_TRD]) + byte_collisions[CURRENT_TRD] < DESIRED_COLLISION){
                    break; 
                }

                if ((hashes[i[CURRENT_TRD]][k[CURRENT_TRD]] == hashes[j[CURRENT_TRD]][k[CURRENT_TRD]])){
                    byte_collisions[CURRENT_TRD]++;
                } 
            }

            if(byte_collisions[CURRENT_TRD] >= DESIRED_COLLISION){
                printf("==> %d bytes collision found!!!! Iteration: %d\n", byte_collisions[CURRENT_TRD], i[CURRENT_TRD]);
                printf("md5('%ld')\t==\t%s\nmd5('%ld')\t==\t%s\n", values[i[CURRENT_TRD]], hashes[i[CURRENT_TRD]], values[j[CURRENT_TRD]], hashes[j[CURRENT_TRD]]);

                printf("Thread: %d\nI: %d\nJ: %d\nK: %d\n", CURRENT_TRD, i[CURRENT_TRD], j[CURRENT_TRD], k[CURRENT_TRD]);
                printf("values[%d] = hashes[%d]\nvalues[%d] = hashes[%d]\n\n", i[CURRENT_TRD], i[CURRENT_TRD], j[CURRENT_TRD], j[CURRENT_TRD]);

            }

        }
    }
        
    printf("Finished search for collision\n");
    printf("Time elapsed: %f seconds\n", ((double)clock() - start) / CLOCKS_PER_SEC);
    printf("Time elapsed: %f minutes\n", (((double)clock() - start) / CLOCKS_PER_SEC) / 60);
    printf("Time elapsed: %f hours\n", ((((double)clock() - start) / CLOCKS_PER_SEC) / 60) / 60);

    return 0;
}
