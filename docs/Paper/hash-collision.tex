\documentclass[letterpaper,conference]{IEEEtran}

\usepackage[margin=1.14in]{geometry}
\usepackage{graphicx,url}
\usepackage{amsthm}
\usepackage{listings}
\newtheorem{definition}{Definition}




\begin{document}

\title{Context aware security approach for IoT environments}
\author{\IEEEauthorblockN{Giovani Ferreira and Rafael}
\IEEEauthorblockA{Universal Internet of Things (UIoT)\\ 
Tecnology Faculty (FT)\\
University of Brasília (UFSC)\\
70910-900 – Brasília, DF – Brazil\\
giovani.silva@redes.unb.br, caio.silva@redes.unb.br}
}

\maketitle

\begin{abstract}
adhaskjdhaksjd \cite{tanenbaum2002distributed}
\end{abstract}

\begin{IEEEkeywords}
security, quality of context, Internet of things
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Introduction}

Collision search is an important tool in cryptanalysis. A broad range of cryptanalytic problems
such as computing discrete logarithms, finding hash function collisions, and meet-in-the-middle
attacks can be reduced to the problem of finding two distinct inputs, a and b, to a function f such
that f(a) = f(b) \cite{van1999parallel}.

\section{Related Concepts} 

\subsection{Message Integrity}

Message integrity is normally maintained via the protocol called “MAC" or Message Authentication Code. 
To briefly explain its mechanism,

No mundo digital, as tecnicas de transmissao e manutencao da integridade das mensagens estao em constante
evolucao, visando alcancar protocolos mais eficientes e seguros. A seguranca de um protocolo pode ser ameacada
por inumeros fatores diferentes, alguns possivelmente nem conhecidos ainda, e exige um tempo razoavel de 
estudo, testes e ataques para ter a possibilidade de ser usado em aplicacoes reais.

O protocolo de autenticacao HMAC pode ser entendido em detalhes em \cite{krawczyk1997hmac}, mas como uma breve
introducao, consideremos o seguinte exemplo: Alice deseja se comunicar com Bob, a integridade deve ser
mantida, ou seja, the message should not be tampered with or changed to contain false or modified information:
\begin{enumerate}
\item Alice gera uma signing tag S(k, m), for m = message and k = secret key between Alice and Bob.
\item Bob ao receber a mensagem, runs a verification algorithm, defined by V(k, m, tag) = V(k, m, S(k, m))
\item Using the same key, the algorithm will return 'yes' which shows that message integrity has been mantained \ldots
\end{enumerate}

Dessa forma, Bob eh capaz de identificar que a mensagem enviada por Alice nao foi comprometida e seu conteudo
eh exatamente o que Alice escreveu.

\subsection{Hash Collision}

Hash functions are designed to take a message of arbitrary bitlength and map it to a fixed size
output called a hash result. Let H: M → R be such a hash function. Typically, hash functions are
constructed from a function h: B×R → R which takes a fixed size block of message bits together
with an intermediate hash result and produces a new intermediate hash result. A given message
m ∈ M is typically padded to a multiple of the block size and split into blocks m 1 , ... m l ∈ B. The
padding often includes a field which indicates the number of bits in the original message.
Beginning with some constant r 0 ∈ R, the sequence r i = h(m i , r i−1 ) is computed for i = 1, ... l, and
r l is the hash result for message m \cite{van1999parallel}.

\subsection{Birthday Attack}

The birthday paradox is the counter-intuitive principle that for
groups of as few as 23 persons there is already a chance of about one half of finding two 
persons with the same birthday (assuming all birthdays are equally likely and disregarding 
leap years). Compared to finding someone in this group with your birthday where you have 
23 independent chances and thus a success probability of 23/365 ≈ 0.06, this principle is 
based on the fact that there are (23 * 22)/2 = 253 distinct pairs of persons. This leads to 
a success probability of about 0.5 (note that this does not equal 253/365 ≈ 0.7 since these 
pairs are not independently distributed) \cite{stevens2012attacks}.

The following is the general algorithm for the Birthday Attack and in the next section I will discuss
the Birthday Paradox, which is a problem that gave birth to the Birthday Attack algorithm.
1 - Let H:M -> {0,1}\^n be a hash function. From this we know that the size of the tag space is ≈ 2\^n bits
and that |M| >> 2\^n
2 - We choose 2\^(n/2) random messages in M, i.e. m1, m2, ... , m2(n/2) pertencentes a M.
3 - For i = 1,2, ... , 2(n/2) compute ti = H(mi), where ti is the hash value in the tag space.
4 - We then search for any collisions, i.e. ti = tj for i, j pertencentes {1, 2, ... , 2\^(n/2)}. It this is not
found we go back to step 1 and repeat with different message samples.

\subsection{Se pa - Distributed System}
A distributed system is a collection of independent computers that appears to its users as a single 
coherent system \cite{tanenbaum2002distributed}.
 
\section{Experiments and Evaluation}

Foram aplicados tecnicas de paralelismo (openmp) e distribuicao (mpi) visando uma mlehora na performance
da busca por colisao. A funcao hash usada nos testes foi a MD5.

\section{Conclusions and Future work}

\bibliographystyle{IEEEtran}
\bibliography{hash-collision}

\end{document}


