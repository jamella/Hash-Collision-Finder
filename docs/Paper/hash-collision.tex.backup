\documentclass[letterpaper,conference]{IEEEtran}

\usepackage[margin=1.14in]{geometry}
\usepackage{graphicx,url}
\usepackage{amsthm}
\usepackage{listings}
\newtheorem{definition}{Definition}




\begin{document}

\title{Context aware security approach for IoT environments}
\author{\IEEEauthorblockN{Giovani Ferreira and Rafael}
\IEEEauthorblockA{Universal Internet of Things (UIoT)\\ 
Tecnology Faculty (FT)\\
University of Brasília (UFSC)\\
70910-900 – Brasília, DF – Brazil\\
giovani.silva@redes.unb.br, caio.silva@redes.unb.br}
}

\maketitle

\begin{abstract}
adhaskjdhaksjd \cite{tanenbaum2002distributed}
\end{abstract}

\begin{IEEEkeywords}
security, quality of context, Internet of things
\end{IEEEkeywords}

\IEEEpeerreviewmaketitle

\section{Introduction}

Manzoor \cite{tanenbaum2002distributed}

\section{Related Concepts} 

A distributed system is a collection of independent computers that appears to its users as a single 
coherent system \cite{tanenbaum2002distributed}.

Collision search is an important tool in cryptanalysis. A broad range of cryptanalytic problems
such as computing discrete logarithms, finding hash function collisions, and meet-in-the-middle
attacks can be reduced to the problem of finding two distinct inputs, a and b, to a function f such
that f(a) = f(b) \cite{van1999parallel}.

Hash functions are designed to take a message of arbitrary bitlength and map it to a fixed size
output called a hash result. Let H: M → R be such a hash function. Typically, hash functions are
constructed from a function h: B×R → R which takes a fixed size block of message bits together
with an intermediate hash result and produces a new intermediate hash result. A given message
m ∈ M is typically padded to a multiple of the block size and split into blocks m 1 , ... m l ∈ B. The
padding often includes a field which indicates the number of bits in the original message.
Beginning with some constant r 0 ∈ R, the sequence r i = h(m i , r i−1 ) is computed for i = 1, ... l, and
r l is the hash result for message m \cite{van1999parallel}.

The following is the general algorithm for the Birthday Attack and in the next section I will discuss
the Birthday Paradox, which is a problem that gave birth to the Birthday Attack algorithm.
1 - Let H:M -> {0,1}^n be a hash function. From this we know that the size of the tag space is ≈ 2^n bits
and that |M| >> 2^n
2 - We choose 2^(n/2) random messages in M, i.e. m1, m2, ... , m2(n/2) pertencentes a M.
3 - For i = 1,2, ... , 2(n/2) compute ti = H(mi), where ti is the hash value in the tag space.
4 - We then search for any collisions, i.e. ti = tj for i, j pertencentes {1, 2, ... , 2^(n/2)}. It this is not
found we go back to step 1 and repeat with different message samples.
 
\section{Experiments and Evaluation}

\section{Conclusions and Future work}

\bibliographystyle{IEEEtran}
\bibliography{hash-collision}

\end{document}


